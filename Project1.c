#pragma config(Sensor, S1,     Touch,          sensorEV3_Touch)
#pragma config(Sensor, S4,     Touch2,          sensorEV3_Touch)
#pragma config(Motor,  motorB,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Flag to stop robot from wandering when handling collisions
int flag = 0;
//This is the random number that will determine if the robot will turn left/right or go straight
int num;
//random time for how long the robot will go left/right/straight
int time;

//method to determine random direction
int randDir() {
	return (rand()% (4))+1;
}

//method to determine random time used for distance
int randTime() {
	return (rand()% (2))+1;
}


//wander algorithm with bias towards going straight
//The rand method will return between 1-4, 2 and 3 are used for Left/Right
void wander() {
		if(flag == 0) { //if a collision isnt being handled

			float  time2= time - .25;
			if(num == 2) { //turn left
				setMotorSpeed(motorLeft, 30);
				setMotorSpeed(motorRight, 60);
				sleep(time2 * 350);

			} else if(num ==3) { //turn right
				setMotorSpeed(motorLeft, 60);
				setMotorSpeed(motorRight, 30);
				sleep(time2 * 350);


			} else{ //else go straight
				setMotorSpeed(motorLeft, 60);
				setMotorSpeed(motorRight, 60);
				sleep(time2 * 400);
			}


		}

	}

	void turnRight() {
				setMotorSpeed(motorLeft, -50);	//back up
				setMotorSpeed(motorRight, -50);
				sleep(1000);
				setMotorSpeed(motorRight, 0);
				setMotorSpeed(motorLeft,0);	//turn right
				setMotorSpeed(motorLeft,50);
				int sleepTime = (random(2) +1) * 500;
				sleep(sleepTime);
				setMotorSpeed(motorRight, 0);

}

	void turnLeft() {
				setMotorSpeed(motorLeft, -50); //backup
				setMotorSpeed(motorRight, -50);
				sleep(1000);
				setMotorSpeed(motorRight, 0);
				setMotorSpeed(motorLeft,0); //turn left
				setMotorSpeed(motorRight, 50);
				int sleepTime = (random(2) +1) * 500;
				sleep(sleepTime);
				setMotorSpeed(motorLeft, 0);
}


void backUp() {
			setMotorSpeed(motorLeft, -50);		//back up
			setMotorSpeed(motorRight, -50);
			sleep(750);
			setMotorSpeed(motorRight, 0);
			setMotorSpeed(motorLeft,0);
			sleep(2000);										//pause 2 sec
}

//checking collisions
	void checkCollision() {
		if(SensorValue[Touch]) { //if left bumper
			sleep(100);						// wait a small time
			if(SensorValue[Touch2]) {  //if right bumper
				playSound(soundBeepBeep); //play sound then backup
				backUp();
			} else {
				turnRight();			//else turn right
			}
		} if(SensorValue[Touch2]){	//if right bumper
				sleep(100);							//wait
				if(SensorValue[Touch]) {	//if left bumper
				playSound(soundBeepBeep);		//play beep then backup
				backUp();
			} else {
				turnLeft();			//else turn left
			}

		}
		flag = 0;	//set collision flag to 0
	}


	//task to check collisions
task stopRobot() {
	while(true) {
		if(SensorValue[Touch] || SensorValue[Touch2]) {
			flag = 1;		//set flag to 1, collision being handled
			checkCollision();

		}

	}
}



task main() {
	startTask(stopRobot); //starts the task that will handled collisions
	while(true) {
		if(!flag) { //while true, if the flag hasnt been set, calc a random time and direction, then wander.
			time = randTime();
			num = randDir();
			wander();
		}
	}

}
